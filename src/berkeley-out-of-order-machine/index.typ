= The Berkeley Out-of-Order Machine

The Berkeley Out-of-Order Machine (BOOM) is an open-source-software (OSS) project from the University of California, Berkeley (UC Berkeley).
It is an implementation of a 64-bit RISC-V processor

== RISC-V

The BOOM uses the RISC-V ISA, which is also developed at UC Berkeley @bib:riscv.
RISC-V is, as its name might imply, a RISC architecture.
The ISA has many variants and different extensions.

The BOOM uses the 64-bit base variant of RISC-V, rv64.
This variant specifies a base machine with 32 64-bit registers and instructions operating on 64-bit and 32-bit values.
Several instruction format variants are defined for different instruction types.
Some instructions require no destination register, while others require immediate values encoded in the instructions.
Instructions have a fixed size of 32 bits.
The PC is aligned at a four-byte boundary (the lower two bits of the PC are always 0).

=== Compressed Instructions

RISC-V supports instructions shorter than 32 bits through the C-extension.
The C-extension specifies a 16-bit instruction format for several common instructions and reduces the alignment requirement of the PC to a two-byte boundary (the lowest bit is always 0).
Even 32-bit instructions may start on any two-byte boundary.

The BOOM supports this extension, among many others.

=== Privileged Architecture

The RISC-V specification is split in a user-level architecture, and a privileged architecture.
The user-level architecture contains functionality most relevant to pure computation like branches, arithmetic, and memory instructions.
The privileged architecture contains functionality that is only available when executing in a privileged mode.
The privileged architecture specifies a scheme for virtual memory using pages of 4096 bytes (4 KiB).

Additionally, the privileged architecture specifies a number of _control and status registers_ (CSRs) that control the behaviour of the processor.
By writing different values to these registers, a programmer can manage the current execution mode, set up and control virtual memory, and control many other aspects of execution.
The CSR file additionally contains a number of _hardware performance counters_ (HPMs) to allow tracking things like time, the number of cycles, and the number of executed instructions.

== Development

Development in the BOOM project uses various tools 

=== Chisel

Chisel @bib:chisel-paper is a library of components and operations on those components written in Scala @bib:scala-lang.
Scala is a functional programming language built on top of the _java virtual machine_ (JVM).

Scala allows defining arbitrary operators which has enabled the developers of Chisel to create a system of various components that can be connected together with something that resembles a _domain-specific language_ (DSL), but is still fundamentally "just Scala".
Because Chisel is not its own language, but embedded in Scala, it is what is referred to as an _embedded_ DSL (eDSL).
Chisel in combination with Scala becomes its own eDSL HDL.

When writing a program in Scala using Chisel, the compiled code is a Scala program.
When running the Scala program, a Chisel _graph_ is generated by going through the code and instantiating components and connecting them together as specified by the program.
The code can include things like loops, variable reassignments, and everything else that normal Scala has to offer.
This is the real genius of Chisel: Scala can be used as a very powerful meta-programming language around Chisel.

The Chisel graph is verified against certain rules such as no disconnected inputs to modules, no combinational loops, and more.
The Chisel graph might go through rudimentary optimisations by eliminating unused signals and other restructuring.

Finally, the graph can be used for purposes like simulation by tweaking input and output signals from code written in Scala.
However, the built-in simulator for the Chisel graph can be slow.
The graph can be used to output code in other HDLs such as VHDL or SystemVerilog which can in turn be used by other tools.

=== Verilator

Verilator is a program that accepts SystemVerilog and translates the code to a multithreaded implementation of a simulator in C++.
This code is then compiled to create the final simulator.

Verilator gives a much faster simulator than simulating the Chisel graph directly and still preserves some of the nice debugging features that are available directly in Chisel such as printing debug information while simulating.

=== FireSim

FireSim is 

== Architecture and Implementation of Key Components

The BOOM uses, as the name would imply, an OoO microarchitecture.
Here, we present the components of the BOOM that are relevant to this text.
We may mention other components that are not fully explained, but their naming should give clear hints to their operation.

=== High-Level Architecture and Code Organisation

=== Anatomy of a Micro-operation

=== Re-Order Buffer

=== Memory Issue Units

=== Address Generation Units

=== Load-Store Unit

==== Load Queue

==== Translation Lookaside Buffer

==== Connection to Address Generation Units

==== Deciding Which Operations to Perform

==== Tracking Load Instructions

=== Data Cache

==== Miss Status Holding Registers
